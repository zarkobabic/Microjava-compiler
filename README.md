# MicroJava Compiler
![Untitled](https://github.com/zarkobabic/Microjava-compiler/assets/92127059/5a4ec5ab-2712-49d6-a213-c5104a8039b9)

## Navigation

- [Overview](#overview)
- [Project Components](#project-components)
- [Lexing in General](#lexing-in-general)
- [Parsing in General](#parsing-in-general)
- [Syntax Analysis in General](#syntax-analysis-in-general)
- [Code Generation in General](#code-generation-in-general)
- [Usage](#usage)
- [License](#license)

## Overview

This repository hosts the source code and documentation for the **MicroJava Compiler**, a Java-based compiler for the **MicroJava** programming language. MicroJava is a small, educational programming language, and this compiler is designed to convert MicroJava source code into bytecode that can be executed on the MicroJava Runtime Machine.

## Project Components

The MicroJava Compiler consists of four primary components:

1. **Lexer**:
   - Implemented using [jFlex](https://jflex.de/), the lexer analyzes the source code and tokenizes it based on the MicroJava language specification. It identifies and classifies language constructs, such as keywords, operators, and identifiers. This lexer is a crucial initial step in the compilation process.

2. **Parser**:
   - Implemented using [CUP](http://www2.cs.tum.edu/projects/cup/), the parser takes the tokenized output from the lexer and constructs an Abstract Syntax Tree (AST) following the MicroJava language specification. It enforces the language's syntax rules, ensuring that the source code adheres to the correct structure and order of statements and expressions.

3. **Syntax Analysis**:
   - In this phase, the AST generated by the parser is analyzed to enforce the constraints of the MicroJava language. Syntax analysis ensures that the code follows the correct grammar, handles operator precedence, type checking, and validates the program's structure.

4. **Code Generation**:
   - The final phase of the compiler is responsible for generating executable bytecode for the MicroJava Runtime Machine. This process translates the validated AST into instructions that can be executed on the MicroJava virtual machine, enabling the execution of MicroJava programs.

## Lexing in General

Lexing, also known as tokenization, is the process of breaking down the source code into a stream of tokens. Tokens are the smallest units of a programming language and include keywords, identifiers, operators, and literals. The lexer's role is to recognize and classify these tokens based on the language's grammar and rules.

## Parsing in General

Parsing is a crucial step in the compilation process that follows lexing. It involves the analysis of the tokenized source code to determine its structure and relationships between different elements. In this phase, a parser constructs an Abstract Syntax Tree (AST) that represents the program's syntax according to the language's grammar. It enforces the correct order of statements, expressions, and the overall program structure.


## Syntax Analysis in General

Syntax analysis, also known as parsing, is an essential part of any compiler. It ensures that the source code adheres to the rules and grammar of the target programming language. During this phase, the compiler constructs a structured representation of the code (such as an AST) and performs various checks to ensure correctness. Common tasks in syntax analysis include identifying and reporting syntax errors, handling operator precedence, and building a representation of the program that can be used for further processing and code generation.

## Code Generation in General

Code generation is the final phase of a compiler, responsible for producing executable code from the parsed and analyzed source code. During this phase, the compiler generates code that can be executed on the target platform, such as machine code or bytecode. The generated code should adhere to the rules and specifications of the target platform and be semantically equivalent to the original source code.

## Usage

The MicroJava Compiler can be used by students and educators as a learning tool for understanding the principles of compiler construction. To build and use the compiler, please refer to the instructions provided in the repository's documentation.

##Documentation

Microjava is similar
to Java, but much simpler.
A.1 General features of the language
- A MikroJava program starts with a keywordthe programand has static fields, static methods, and
inner classes that can be used as (user) data types.
- The main method of a MikroJava program is always calledmain().When a MikroJava program is
called, that method is executed.
- Since:
- Integer, sign and logical constants (int, char, bool).
- Basic types:int, bool, char (ASCII).
- Variables: global (static), local, class (fields).
‐ Variables of basic types contain values.
‐ Structured/reference types: one-dimensional arrays as in Java and inner classes with fields and
methods.
- Variables of reference types represent references (they contain addresses that cannot be changed
explicitly).
- Static methods in the program.
- There is no garbage collector (allocated objects are only deallocated after the end of the program).
- There is class inheritance and polymorphism.
- There is a redefinition of methods.
- Methods of inner classes are bound to the instance and have an implicit parameterthis (a reference to the instance of
the class for which the method was called).
- The reference "this" is implicitly declared in the methods of inner classes as the first formal argument of the reference
type to the class to which the method belongs.
‐ Within instance methods, the field name refers to the instance field of the current object, assuming
the field is not hidden by a method parameter. If it is hidden, we can access the instance field via
this.fieldName.
- Pre-declared procedures areord, chr, len.
- Methodprintprints the values of all basic types.
- Control structures include conditional branching (if-else) and cycle (do-while).
Translated from Serbian to English - www.onlinedoctranslator.com
Example program
program p
const int size = 10; class
Tables {
int pos[], neg[], factor; {
Table(int factor) {this.factor = factor;} void
void
int
int
putp (int a, int idx) { this.pos[idx] = a; } putn (int a, int idx)
{ this.neg[idx] = a; } getp (int idx) { return pos[idx]; }
getn (int idx) { return neg[idx]; }
}
}
Table wave;
Int rows, columns;
{
void f(char ch, int a, int arg)
int x;
{
x = arg;
}
void main() int x, i; char c, int arr[]; {
val = new Table(2); arr =
new int[3]; i = 0;
while (i<3) {
arr[i]
and++;
= and;
}
arr.foreach(x
val.pos = new int [size]; val.neg =
new int [size]; read(x);
=> print(x););
[i,,x]
while
= arr;
(i<size) {
val.putp(0,
wave.putn(0,
and++;
i);
i);
}
f(c, x, i);
read(rows);
x = rows;
while (true){
if(x <= 0) break; if (0 <= x && x <
size) {
val.putp(val.getp(x)+1);
}
else if (‐size < x && x < 0) {
val.putn(val.getn(‐x)+1);
}
read(x);
}
}
}
A.2 Syntax
The program
ConstDecl
= "program" ident {ConstDecl | VarDecl | ClassDecl } "{" {MethodDecl} "}".
= "const" Type ident"="(numConst | charConst | boolConst) {, ident "=" (numConst |
charConst | boolConst)} ";".
=
=
=
VarDecl
ClassDecl
ConstructorDecl
MethodDecl
FormPars
Type
Statement
Type ident ["[" "]"] {"," ident ["[" "]"]} ";".
"class" ident ["extends" Type] "{" {VarDecl} ["{" {ConstructorDecl} {MethodDecl} "}"] "}". ident
"(" [FormPars] ")" {VarDecl} "{" {Statement} "}.* for C level (Type | "void") ident "(" [FormPars]
= ")" {VarDecl} "{" {Statement} "}". Type ident ["[" "]"] {"," Type ident ["[" "]"]}.
=
= identical
= DesignatorStatement ";"
| "if" "(" Condition ")" Statement ["else" Statement] |
|
|
|
| "read" "(" Designator ")" ";"
| "print" "(" Expr ["," numConst] ")" ";"
| Designator "." "foreach" "(" ident "=>" Statement ")" ";" |
=
|
= Expr {"," Expr}. =
=
= Expr [Relop Expr].
= ["‐"] Term {Addop Term}. =
Factor {Mulop Factor}.
= Designator ["(" [ActPars] ")"] |
numConst
| charConst
|boolConst
| "new" Type ( "[" Expr "]" | "(" [ActPars] ")" ) |
"(" Expr ")".
= ident {"." identical | "[" Expr "]"}. =
identical
= "=".
= "==" | "!=" | ">" | ">=" | "<" | "<=".
= "+" | "-".
= "*" | "/" | "%".
"while" "(" Condition ")" Statement
"break" ";"
"continue" ";"
"return" [Expr] ";"
* for B and C level
"{" {Statement} "}".
Designator (Assignop Expr | "(" [ActPars] ")" | "++" | "‐‐")
"[" [Designator] {"," [Designator]}"]" "=" Designator.
DesignatorStatement
ActPars
Condition
CondTerm
CondFact
Expr
Term
Factor
CondTerm {"||" CondTerm}.
CondFact {"&&" CondFact}.
Designator
Label
Assignop
Relop
Addop
Mullop
Lexical Structures
Key words: program, break, class, else, const, if, while, new, print, read, return,
void, extends, continue, foreach
Token Types : ident = letter {letter | digit | "_"}.
numConst = digit {digit}.
charConst = "'" printableChar "'".
boolConst = ("true" | "false").
+ , ‐ , * , /, %, ==, !=, >, >=, <, <=, &&, ||, =, ++, ‐‐, ;, :, comma, ., (, ), [, ], {, }, => // to
the end of the line
Operators:
Comments:
A.3 Semantics
All defined terms in this document are underlined to emphasize their particular meaning. Definitions
of those terms are given below.
Reference type
Arrays and classes are of reference type.
Constant type
- The type of an integer constant (eg 17) is int.
- The type of a character constant (eg 'x') is char.
- The type of a logical constant (eg true) is bool.
Equivalent Data Types Two data
types are equivalent
- if they have the same name, or
- if both are strings, and the types of their elements areequivalent .
Compatible data types The two
data types are compatible
- if they are equivalent, or
- if one of themreference type , and the other is of typenull.
Compatibility of data types when assigning Type
heartis compatible when assigned to typedst
- if they areheartanddstequivalent ,
- if it isdstreference type , aheartis of the typenull.
- if dst is a reference to a base class and src is a reference to a derived class
Predeclared names
int
char
bool
null
type of all integer values type
of all character values
boolean type
the null value of a variable of type class or (character) string symbolically indicates a reference
that does not point to any data
aeolian -end of character line (corresponds to the character '\n'); print(eol) makes a transition to a new line chr ‐
standard method; chr(i) performs the conversion of an integer expressionandto character (char) ord ‐standard
method; ord(ch) performs character conversionchto an integer value (int)
Scope of validity
Validity range (scope)represents the textual reach of a method or class. It extends from the beginning of
the method or class definition to the closing brace at the end of that definition. A scope does not include
names declared in scopes that are lexically nested within it. In a scope, the names declared within it and all
scopes outside it are "seen". The assumption is that there is an artificial global scope (universe), for which
the main program is local and which contains all pre-declared names.
Name declaration in inner scopeShides the declaration of the same name in the outer scope.
Note
• Indirect recursion is not allowed and each name must be declared before its first use.
• Predeclared names (eg int or char) can be redeclared in the inner scope (but this is not
recommended).
A.4 Contextual conditions
General contextual conditions
• Each name in the program must be declared before first use.
• A name must not be declared multiple times within the same scope.
• There must be a named method in the programmain.It must be declared as a void method with no
arguments.
Context conditions for standard methods chr(s)
emust be an expression of type int. ord(c)cmust
be of type char. len(s)amust be a string or
character string.
Context requirements for MikroJava shifts
Program = "program" ident {ConstDecl | VarDecl | ClassDecl | RecordDecl } "{" {MethodDecl} "}".
ConstDecl = "const" Type ident "=" (numConst | charConst | boolConst) ";".
• Terminal typenumConst, charConst or boolConstIt has to beequivalent to the guyType.
VarDecl = Type ident ["[" "]"] {"," ident ["[" "]"]} ";".
ClassDecl = "class" ident ["extends" Type] "{" {VarDecl} ["{" {ConstructorDecl} {MethodDecl} "}"] "}".
• TypeTypewhen deriving a class from another class, it must be an inner class of the main program.
MethodDecl = (Type | "void") ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}".
• If the method is not of type void, it must have a return statement within its body (the condition should be checked at
program execution time).
ConstructorDecl = ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}".
• A class constructor must have the same name as the class for which it is defined.
• There cannot be two constructors within the same class with the same formal parameters.
FormPars = Type ident ["[" "]"] {"," Type ident ["[" "]"]}.
Type = ident.
• identmust indicate a data type.
Statement = DesignatorStatement ";".
DesignatorStatement = Designator Assignop Expr ";".
• Designatormust denote a variable, array element, or field within an object.
• Non-terminal typeExprIt has to becompatible at assignment with non-terminal typeDesignator.
DesignatorStatement = Designator ("++" | "--") ";".
• Designatormust denote a variable, array element, or field of an inner class object.
• Designatormust be of type int.
DesignatorStatement = Designator "(" [ActPars] ")" ";".
• Designatormust denote a non-static method of the inner class or a global function of the main
program.
DesignatorStatement = "[" [Designator] {"," [Designator]}"]" "=" Designator
• All ofDesignatornonterminals to the left of the assignment character must denote a variable, array
element, or field within an object.
• Designatorto the right of the assignment character must represent a string.
• An array element type represented by a nonterminalDesignatorto the right of the assignment sign
must becompatible at assignment with the type of all non-terminalsDesignatorto the left of the
value assignment sign.
• Depending on the listing order,Designatorto the left of the assignment character will get the value of the
corresponding array element (the first listedDesignatortakes the value of the null element of the array, the
second specifiedDesignatortakes the value of the first element of the array, etc.).
• If not specifiedDesignatorafter the character ",", the corresponding element of the string is skipped.
• In case multiple non-terminals are specified to the left of the value assignment characterDesignatorof
string length, need to report an error at runtime (runtime error).
Statement = "break".
• The break statement can be usedonlyinside ofwhileorforeachloops. Aborts executionimmediately
surroundingloops.
Statement = "continue".
• The continue statement can be usedonlyinside ofwhileorforeachloops. Terminates the current iteration
immediatelysurroundingloops.
Statement = "read" "(" Designator ")" ";".
• Designatormust denote a variable, array element, or field within an object.
• Designatormust be of type int, char, or bool.
Statement = "print" "(" Expr ["," numConst] ")" ";".
• Exprmust be of type int, char, or bool.
Statement = "return" [Expr] .
• Non-terminal typeExprmust be equivalent to the return type of the current method/global function.
• If non-terminalExpris missing, the current method must be declared void.
• It must not exist outside the body of (static) methods, i.e. global functions.
Statement = "if" "(" Condition ")" Statement ["else" Statement].
• If command - if the value of the conditional expressionConditiontrue, the statements in the if branch are executed,
otherwise the statements in the else branch are executed, if specified.
• Conditional expression typeConditionIt has to bebool.
Statement = "while" "(" Condition ")" Statement.
• Conditional expressionConditionmust be of typebool.
• When entering the loop, as well as at the end of the loop body (unless it is encounteredbreak) the
specified condition is checked. If the condition is met, it jumps to the beginning of the loop, while
otherwise it exits the loop.
Statement = Designator "." "foreach" "(" ident "=>" Statement ")" ";".
• Designatormust denote a string of arbitrary type.
• identmust be a local or global variable of the same type as the elements of the array described by the
Designator.
• In each iteration of the loopidentindicates the current element of the array, with iteration starting from the first one
element of the array and ends with the last one.
• identcannot be used to change the value of an array element - only reading is allowed, not writing.
ActPars = Expr {"," Expr}.
• The number of formal and actual arguments of a method or constructor must be the same.
• The type of each actual argument must becompatible at assignment with the type of each formal
argument in the appropriate position.
Condition = CondTerm {"||" CondTerm}.
CondTerm = CondFact {"&&" CondFact}.
CondFact = Expr Relop Expr.
• The types of both expressions must be compatible.
• With variables of class or array type, only != and == can be used from the relational operators.
Expr = Term.
Expr = "-" Term.
• Termmust be of type int.
Expr = Expr Addop Term.
• ExprandTermmust be of type int. Anyway, guys forExprandTermthey must be comatible.
Term = Factor.
Term = Term Mullop Factor.
• TermandFactormust be of type int.
Factor = Designator | numConst | charConst |boolConst | "(" Expr ")".
Factor = Designator "(" [ActPars] ")".
• Designatormust denote a non-static method of an inner class, a constructor of an inner class, or a
global function of the main program.
Factor = "new" Type "[" Expr "]".
• Non-terminal typeExprmust be an int.
Factor = "new" Type "(" [ActPars] ")".
• Non-terminalTypemust denote an inner class (user-defined type).
Designator = Designator "." ident.
• Non-terminal typeDesignatormust be an inner class (identmust be either a field or a method of an object
marked with a nonterminalDesignator).
Designator = Designator "[" Expr "]".
• Non-terminal typeDesignatormust be a string.
• Non-terminal typeExprmust be an int.
Assignop = "=".
The assignment operator is right associative.
Relop = "==" | "!=" | ">" | ">=" | "<" | "<=".
Addop = "+" | "-". Operators are
left associative.
mulop = "*" | "/" | "%".
Operators are left associative.
A.5 Implementation Limitations
• No more than 256 local variables may be used.
• No more than 65536 global variables may be used.
• A class cannot have more than 65536 fields.
• The source code of the program must not exceed 8 KB.


## License

This project is open source and available under the [MIT License](LICENSE). Feel free to use, modify, and distribute the code, respecting the terms and conditions of the license.

For any questions or feedback, please don't hesitate to [contact us](mailto:your-email@example.com).

Thank you for your interest in the MicroJava Compiler project. We hope it serves as a valuable resource for understanding compiler construction and the MicroJava programming language.
